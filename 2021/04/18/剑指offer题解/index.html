<!DOCTYPE html>


  <html class="light page-name">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>剑指offer题解 | Hexo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="算法,">
  

  <meta name="description" content="前言将剑指offer的题目中的算法解题思路作为笔记记录下来。题目来自《何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.》，刷题网站推荐：牛客网leetcode   数组与矩阵3.数组中重复的数字题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题解">
<meta property="og:url" content="http://yoursite.com/2021/04/18/剑指offer题解/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言将剑指offer的题目中的算法解题思路作为笔记记录下来。题目来自《何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.》，刷题网站推荐：牛客网leetcode   数组与矩阵3.数组中重复的数字题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/image/offer3_6.jpg">
<meta property="og:image" content="http://yoursite.com/image/offer3_2.png">
<meta property="og:image" content="http://yoursite.com/image/offer3_3.png">
<meta property="og:image" content="http://yoursite.com/image/offer3_4.png">
<meta property="og:image" content="http://yoursite.com/image/offer3_5.png">
<meta property="og:image" content="http://yoursite.com/image/offer4_1.png">
<meta property="og:image" content="http://yoursite.com/image/offer4_2.png">
<meta property="og:image" content="http://yoursite.com/image/offer4_3.png">
<meta property="og:image" content="http://yoursite.com/image/offer4_4.png">
<meta property="og:image" content="http://yoursite.com/image/offer9_1.png">
<meta property="og:image" content="http://yoursite.com/image/offer9_2.jpeg">
<meta property="og:image" content="http://yoursite.com/image/offer30_1.png">
<meta property="og:updated_time" content="2021-05-07T02:28:38.253Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer题解">
<meta name="twitter:description" content="前言将剑指offer的题目中的算法解题思路作为笔记记录下来。题目来自《何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.》，刷题网站推荐：牛客网leetcode   数组与矩阵3.数组中重复的数字题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找">
<meta name="twitter:image" content="http://yoursite.com/image/offer3_6.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组与矩阵"><span class="toc-text">数组与矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-数组中重复的数字"><span class="toc-text">3.数组中重复的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-二维数组中查找"><span class="toc-text">4.二维数组中查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-替换空格"><span class="toc-text">5.替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-顺时针打印矩阵"><span class="toc-text">29.顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-第一个只出现一次的字符"><span class="toc-text">50.第一个只出现一次的字符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈队列堆"><span class="toc-text">栈队列堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-用两个栈实现队列"><span class="toc-text">9.用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-包含min函数的栈"><span class="toc-text">30.包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-栈的压入、弹出序列"><span class="toc-text">31.栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-最小的k个数"><span class="toc-text">40.最小的k个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-数据流中的中位数"><span class="toc-text">41.数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-1滑动窗口的最大值"><span class="toc-text">59.1滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-2-队列的最大值"><span class="toc-text">59.2 队列的最大值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#双指针"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#57-1和为s的两个数字"><span class="toc-text">57.1和为s的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-2和为s的连续正数序列"><span class="toc-text">57.2和为s的连续正数序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-从尾到头打印链表"><span class="toc-text">6.从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-删除链表的节点"><span class="toc-text">18.删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-链表中倒数第k个节点"><span class="toc-text">22.链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-反转链表"><span class="toc-text">24.反转链表</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="name-剑指offer题解" class="article article-type-name" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">剑指offer题解</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.04.18</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>lxlandzyq</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将剑指offer的题目中的算法解题思路作为笔记记录下来。<br>题目来自《何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.》，刷题网站推荐：<br><a href="https://www.nowcoder.com/ta/coding-interviews?from=cyc_github" target="_blank" rel="noopener">牛客网</a><br><a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">leetcode</a>  </p>
<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h2><p><strong>题目描述</strong><br>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>题目要求数字的范围是在0 ~ n-1的范围内，则表示：</p>
<ul>
<li>当数组中没有重复数字的时候，每个索引的值是对应其索引下标值的。  </li>
<li>当数组有重复的时候，有些索引下是有多个值，有些索引下是无值的，具体如下图。<br><img src="/image/offer3_6.jpg" alt><br>为表达这种形式，我们开始排列这个数组<br>index = 0，value = 2 则去到index = 2 中将其修改为2<br><img src="/image/offer3_2.png" alt><br>index = 2，value = 1 则去到index = 1 中将其修改为1<br><img src="/image/offer3_3.png" alt><br>index = 1，value = 3 则去到index = 3 中将其修改为3<br><img src="/image/offer3_4.png" alt><br>index = 3，value = 0 则去到index = 0 中将其修改为0<br><img src="/image/offer3_5.png" alt><br>形成闭环，此时都没有出现重复数字，0 到 3的索引都为一次<br>当下标索引指向4的时候<br>index = 4 ,value = 2 此时index = 2中已经为 2，则表明2重复了，输出其值<br>具体代码如下  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        for (int i = 0 ; i &lt; length; i++)&#123;</span><br><span class="line">            while (nums[i]!= i)&#123;</span><br><span class="line">                if (nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                    return nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums,i,nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] num,int i,int j)&#123;</span><br><span class="line">        int t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码尽管有两重循环，但每个数字最多只要交换两次就能找到属于自己的位置，因此时间复杂度为O(n)，空间复杂度为O(1)。</p>
<h2 id="4-二维数组中查找"><a href="#4-二维数组中查找" class="headerlink" title="4.二维数组中查找"></a>4.二维数组中查找</h2><p><strong>题目描述</strong><br>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>示例1：<br>现有矩阵matrix如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定target = 5， 返回true<br>给定target = 20， 返回false<br><strong>解题思路</strong><br>由题目知道，从左到右递增，从上到下也为递增。如果从左上角出发判断的话，无法确定具体是走右边还是走下边可以找到其值，因此从右上角出发。<br>右上角出发： </p>
<ul>
<li><p>当该值大于target值的时候，表明target值左边，向左移动，如图所示，寻target = 5，15大于5。  </p>
<img src="/image/offer4_1.png" width="150" height="150" alt="图片名称">   
<img src="/image/offer4_2.png" width="150" height="150" alt="图片名称">   
</li>
<li><p>当该值小于target值的时候，表明target值在右边，向下移动，如图所示。   </p>
</li>
</ul>
<img src="/image/offer4_3.png" width="150" height="150" alt="图片名称">   
 <img src="/image/offer4_4.png" width="150" height="150" alt="图片名称">   


<p>具体代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;</span><br><span class="line">        if (matrix.length==0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int colum = matrix.length;</span><br><span class="line">        int row = matrix[0].length;</span><br><span class="line">        int indexrow = row-1;</span><br><span class="line">        int indexcolum = 0;</span><br><span class="line">        while(indexrow &gt;= 0 &amp;&amp; indexcolum &lt; colum)&#123;</span><br><span class="line">            if (matrix[indexcolum][indexrow] &gt; target)&#123;</span><br><span class="line">                indexrow--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (matrix[indexcolum][indexrow] &lt; target)&#123;</span><br><span class="line">                indexcolum++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><p><strong>题目描述</strong><br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。  </p>
<p>示例1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong></p>
<ul>
<li>一个空格为一个字符，所以20%为三个字符，遍历字符串，遇到一个空个加两个空字符。</li>
<li>如果从前面遍历，则需要移动的次数比较多，所以从后面进行遍历，p1指向原字符串的末尾，p2指向加了空格的末尾，当p1为空格的时候，p2添加20%</li>
<li>当p2遇到p1表明遍历结束，可以退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String replaceSpace(String s) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(s);</span><br><span class="line">        int p1 = sb.length()-1;</span><br><span class="line">        for (char c : s.toCharArray())&#123;</span><br><span class="line">            if (c == &apos; &apos;)</span><br><span class="line">                sb.append(&quot;  &quot;);//加两个</span><br><span class="line">        &#125;</span><br><span class="line">        int p2 = sb.length()-1;</span><br><span class="line">        while(p1&gt;=0 &amp;&amp;p1&lt;p2)&#123;</span><br><span class="line">            char c = sb.charAt(p1--);</span><br><span class="line">            if (c ==&apos; &apos;)&#123;</span><br><span class="line">                sb.setCharAt(p2--,&apos;0&apos;);</span><br><span class="line">                sb.setCharAt(p2--,&apos;2&apos;);</span><br><span class="line">                sb.setCharAt(p2--,&apos;%&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                sb.setCharAt(p2--,c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p><strong>题目描述</strong>  </p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>根据图形，从上，右，下，左进行分配。设置二维数组的index1和index2。在两个index边界条件中，如果超出其范围要设定其上一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        if(matrix.length==0)&#123;</span><br><span class="line">            return new int[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int cloum = matrix[0].length;</span><br><span class="line">        int index1 = 0;</span><br><span class="line">        int index2 = 0;</span><br><span class="line">        int[] res = new int[row*cloum];</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            for (int i = 1;i &lt;= cloum; i++)&#123; // 上</span><br><span class="line">                res[count] = matrix[index1][index2];</span><br><span class="line">                count++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            index2--;</span><br><span class="line">            index1++;</span><br><span class="line">            for (int i = 1; i &lt;= row-1; i++)&#123; // 右</span><br><span class="line">                res[count] = matrix[index1][index2];</span><br><span class="line">                count++;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cloum == 1 ||row == 1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            index1--;</span><br><span class="line">            index2--;</span><br><span class="line">            for (int i = 1; i &lt;= cloum-1; i++)&#123; // 下</span><br><span class="line">                res[count] = matrix[index1][index2];</span><br><span class="line">                count++;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index2++;</span><br><span class="line">            index1--;</span><br><span class="line">            for (int i = 1; i &lt;= row-2; i++)&#123;</span><br><span class="line">                res[count] = matrix[index1][index2];</span><br><span class="line">                count++;</span><br><span class="line">                index1--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cloum==2||row==2)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">            cloum = cloum - 2;</span><br><span class="line">            row = row - 2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h2><p><strong>题目描述</strong><br>在字符串s中找出第一个只出现一次的字符。如果没有，返回一个单空格。s只包含小写字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s = &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>最简单的思路即为利用hash表来存储每一个字符，然后判断哪一个的长度为1。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public char firstUniqChar(String str) &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (char c : str.toCharArray())&#123;</span><br><span class="line">            if (!hashMap.containsKey(c))&#123;</span><br><span class="line">                hashMap.put(c,1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                hashMap.put(c,hashMap.get(c)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (char c : str.toCharArray())&#123;</span><br><span class="line">            if (hashMap.get(c) ==1)&#123;</span><br><span class="line">                return c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次扫描的时间复杂度为O(n)。第二次扫描时，同样在O(1)时间内独处一个字符出现的次数，所以时间复杂度认为O(n)。<br>总的时间复杂度O(n)。<br>数组表示方法。<br>将数组代替HashMap，ASCII码只有128个字符，因此可以使用长度为128的整型数组来存储每个字符出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public char firstUniqChar(String str) &#123;</span><br><span class="line">        int[] cnts = new int[128];</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">            cnts[str.charAt(i)]++;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">            if (cnts[str.charAt(i)] == 1)</span><br><span class="line">                return str.charAt(i);</span><br><span class="line">        return &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)，因为128为一个常数。</p>
<h1 id="栈队列堆"><a href="#栈队列堆" class="headerlink" title="栈队列堆"></a>栈队列堆</h1><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h2><p><strong>题目描述</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，<code>deleteHead</code>操作返回-1）<br>示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p>示例2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>先明白含义。<br>栈为先入后出的功能，队列即为先入先出的功能，为实现两个栈实现队列的功能，则两个栈各司其职。</p>
<ul>
<li>栈1，存储输入的数据。</li>
<li>当需要弹出数据的时候，并且栈2为空的时候，则栈1将全部数据弹出，每弹出一个数据就存入到栈2中，最后从栈2中取出数据。<br>具体操作如下。  </li>
</ul>
<p><strong>栈与队列的示意图</strong><br><img src="/image/offer9_1.png" alt><br><strong>双栈实现队列</strong><br><img src="/image/offer9_2.jpeg" alt>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;// 存</span><br><span class="line">    Stack&lt;Integer&gt; stack2;// 取</span><br><span class="line"></span><br><span class="line">    public CQueue() &#123;</span><br><span class="line">        stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void appendTail(int value) &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int deleteHead() &#123;</span><br><span class="line">        if (stack2.isEmpty())</span><br><span class="line">            while (!stack1.isEmpty())</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        return stack2.isEmpty()?-1:stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p><strong>题目描述</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)。<br>示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>题目要求：需要一个min()函数查看栈中的最小值。<br>分析：如果是直接利用一个常量min来存储当前的最小值，但当最小值弹出的时候，那么这个常量也需要修改，那么应该修改成什么样子呢？需要遍历一遍栈才可以知道，显然这种方法不行。<br>因为每一个阶段的最小值是不一样的，因此我们可以利用一个min栈来进行存储每一个阶段的最小值。</p>
<p>设置两个栈  </p>
<ul>
<li>一个为普通栈。</li>
<li>一个为min栈。<br>当需要入栈A的时候。</li>
<li>普通栈直接入栈A。</li>
<li>min栈判断A的值是否小于顶部的值，如果小于顶部的值，则将其A压入min栈，如果不小于顶部的值，则将顶部的值再次压入min栈。<br>图示例如下：<br><img src="/image/offer30_1.png" alt><br>当栈中需要弹出内容的时候，min栈也需要将其弹出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">        minStack = new Stack&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        minStack.push(Math.min(min(),x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h2><p><strong>题目描述</strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。<br>示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p>示例2 ：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>


<p><strong>解题思路</strong><br>模拟一个栈，从pushed序列中压入栈，如果压入的元素等于popeed序列中popindex的元素，则弹出栈，popindex+1，判断当前的弹出栈是否相等，相等则继续弹出，否则就继续压入。实则就是模拟了这个过程而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); // 模拟stack</span><br><span class="line">        int popindex = 0;</span><br><span class="line">        int length = pushed.length;</span><br><span class="line">        for (int pushindex = 0; pushindex &lt; length ; pushindex++)&#123;</span><br><span class="line">            stack1.push(pushed[pushindex]);</span><br><span class="line">            while( popindex&lt;length &amp;&amp; !stack1.isEmpty() &amp;&amp; stack1.peek() == popped[popindex])&#123;</span><br><span class="line">                popindex++;</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p><strong>题目描述</strong><br>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br>示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>

<p>示例2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>如果可以修改数组里面的内容，则可以利用快速排序。<br>因为题目要求只需要知道最小的k个元素，如果在下标k下。左边的元素都小于arr[k]，右边的元素都大于arr[k]，则就符合快排的特效，只要利用快排找出这个k即可。  </p>
<ul>
<li>先利用快拍找出第一个索引，分出左右两边</li>
<li>如果索引小于k，则表明k在右边序列中</li>
<li>如果索引大于k，则表明k在左边序列中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        // 利用快排</span><br><span class="line">        quickSql(arr,0,arr.length-1,k);</span><br><span class="line">        return Arrays.copyOf(arr, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void quickSql(int[] arr,int start,int end,int k)&#123;</span><br><span class="line">        if (start &gt; end) return;</span><br><span class="line">        int minddle = partion(arr,start,end);</span><br><span class="line">        if (minddle &gt;= k)&#123;</span><br><span class="line">            quickSql(arr,start,minddle-1,k);</span><br><span class="line">        &#125;else quickSql(arr,minddle+1,end,k);</span><br><span class="line">    &#125;</span><br><span class="line">    public int partion(int[] nums, int start, int end)&#123;</span><br><span class="line">        int dex = nums[start];</span><br><span class="line">        int left = start+1;</span><br><span class="line">        int right = end;</span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            while (left != right &amp;&amp; nums[left] &lt;= dex) left++;</span><br><span class="line">            while (right != left &amp;&amp; nums[right] &gt;= dex) right--;</span><br><span class="line">            if (left != right)&#123;</span><br><span class="line">                swap(nums,left,right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left == right &amp;&amp; nums[right] &gt; dex)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,right,start);</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">        int dex = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = dex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>如果不可修改数组内容。<br>则需要利用外部存储空间，可以利用大根堆来存储数值。应该使用大顶堆来维护最小堆，而不是直接创建一个小顶堆并设置一个大小为k，企图让小顶堆中的元素都是最小元素。<br>维护一个大小为k的最小堆过程如下：</p>
<ul>
<li>使用大顶堆</li>
<li>添加一个元素之后，如果大顶堆的大小大于k，那么将大顶堆的堆顶元素去掉，也就是当前堆中值最大的元素除去，从而使得留在堆中的元素是最小的。</li>
</ul>
<p>Java的PriorityQueue实现了堆的能力，PriorityQueue默认是小顶堆，可以在初始化的时候使用Lamdba表达式(o1, o2) -&gt; o2 - o1来实现大顶堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getLeastNumbers(int[] arr, int k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; max = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);//大顶堆</span><br><span class="line">        for (int i =0 ; i&lt; arr.length;i++)&#123;</span><br><span class="line">            max.add(arr[i]);</span><br><span class="line">            if (max.size() &gt;k)&#123;</span><br><span class="line">                max.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[k];</span><br><span class="line">        for (int i = 0 ; i &lt; k ; i++)&#123;</span><br><span class="line">            res[i] = max.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度O(NlogK) + O(K)</li>
<li>适合海量数据，不改变数组内容。<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h2></li>
</ul>
<p><strong>题目描述</strong><br>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。<br>示例1：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>分析题目，该容器中只能添加元素和查看其中位数这两个功能，因此我们只需要知道容器中位于中间的两个数值即可，可以通过大顶堆和小顶堆进行分队。大顶堆的容器的左边（即其头部为中间的值），小顶堆为容器的右边（即其头部为中间的值）。  当需要取中间值的时候，只需要判断当前的总数来获取其大顶堆和小顶堆的头部值。<br><strong>加入操作</strong>  </p>
<ul>
<li>当加入的总数的为双数的时候，将加入将数值<strong>加入到left大顶堆</strong>，即为左边的区域，然后<strong>再从left左边区域中弹出最大的值，存储到right小顶堆中</strong>。此时右边的个数要比左边的个数多一。</li>
<li>当加入的总数的为单数的时候，将数值加入到right小顶堆，即为右边的区域，然后再从right右边区域中弹出最小的值，存储到left大顶堆中。此时两边个数相等。</li>
</ul>
<p><strong>查看平均值操作</strong>  </p>
<ul>
<li>当总数为双数的时候，则平均值为大顶堆和小顶堆的顶部元素除以2</li>
<li>当总数为单数的时候，则平均值为right小顶堆的顶部元素。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 大顶堆</span><br><span class="line">     */</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 小顶堆</span><br><span class="line">     */</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;&gt;();</span><br><span class="line">    private int count = 0 ;</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    public MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        if (count%2 == 0)&#123;</span><br><span class="line">            left.add(num);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right.add(num);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        if (count%2 == 0)&#123;</span><br><span class="line">            return (left.peek()+right.peek())/2.0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 获取到中间值的时间为O(1)，加入操作的时间为O(logn)</p>
<h2 id="59-1滑动窗口的最大值"><a href="#59-1滑动窗口的最大值" class="headerlink" title="59.1滑动窗口的最大值"></a>59.1滑动窗口的最大值</h2><p>给定一个数组<code>nums</code>和滑动窗口的大小k，请找出所有滑动窗口的最大值。<br>示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>分析问题。  </p>
<ul>
<li>k为一个区域的大小。</li>
<li>k大小的区域先前移动。</li>
<li>找出k这个区域的最大值。</li>
<li>我们可以从第一个窗口看起，其最大值为3，当滑动到下一个窗口的时候，1这个值就不需要了，并且再滑到下一个窗口的时候3也没有了，所以-1可能是过了3之后的最大值，将其记住。</li>
<li>滑动到下一个窗口，此时为-3，其值比-1小，为了考虑过了-1这个值之后-3为最大，所以将其存起。此时长度为[3,-1,-3]窗口。</li>
<li>当滑动到5这个值的时候，其值比前面的-1与-3都大，所以就锁定为最大值5，-1，-3则删掉。</li>
</ul>
<p>因此，这是一个双向队列。  </p>
<ul>
<li>队列的一边，用于输出最大值。</li>
<li>队列另外一边，用于将窗口到达的值中判断是否大于前面存入的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if (nums.length==0 || nums.length &lt; k)&#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[nums.length - k + 1 ];</span><br><span class="line">        Deque&lt;Integer&gt; qmax = new ArrayDeque&lt;&gt;();//双向队列</span><br><span class="line">        for (int j=0,i = 1-k;j&lt;nums.length;j++,i++)&#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; qmax.peekFirst() == nums[i - 1])</span><br><span class="line">                qmax.removeFirst();</span><br><span class="line">            while (!qmax.isEmpty() &amp;&amp; qmax.peekLast() &lt; nums[j])</span><br><span class="line">                qmax.removeLast();</span><br><span class="line">            qmax.addLast(nums[j]);</span><br><span class="line">            if (i &gt;=0)</span><br><span class="line">                res[i] = qmax.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<h2 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59.2 队列的最大值"></a>59.2 队列的最大值</h2><p><strong>题目描述</strong><br>请定义一个队列并实现函数<code>max_value</code>得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code>的均摊时间复杂度都是O(1)。<br>若队列为空，<code>pop_front</code>和<code>max_value</code>需要返回-1<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure>

<p>示例2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>队列是先进后出。即我们可以利用双向队列对队列中的大数进行存储。<br>Max双向队列，一头存储当前的最大值，另外一头存储当当前的最大值被删掉的时候的最大序列。思路与上一题类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; que;</span><br><span class="line">    Deque&lt;Integer&gt; max;</span><br><span class="line">    public MaxQueue() &#123;</span><br><span class="line">        que = new ArrayDeque&lt;&gt;();</span><br><span class="line">        max = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int max_value() &#123;</span><br><span class="line">        return que.isEmpty()?-1:max.peekFirst();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push_back(int value) &#123;</span><br><span class="line">        que.offer(value);</span><br><span class="line">        while (!max.isEmpty() &amp;&amp; value &gt; max.peekLast())</span><br><span class="line">            max.pollLast();</span><br><span class="line">        max.addLast(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop_front() &#123;</span><br><span class="line">        if (que.isEmpty())</span><br><span class="line">            return -1;</span><br><span class="line">        int val = que.poll();</span><br><span class="line">        if (max.peek() == val)</span><br><span class="line">            max.poll();</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="57-1和为s的两个数字"><a href="#57-1和为s的两个数字" class="headerlink" title="57.1和为s的两个数字"></a>57.1和为s的两个数字</h2><p><strong>题目描述</strong><br>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s，如果有多对数字的和等于s，则输出任意一对即可。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>由于此为有序序列，并且只需要两个值即可，因此可以利用双指针。  </p>
<ul>
<li>定义双指针，left与right，在序列中的两端。</li>
<li>当nums[left]+nums[rigth]的值大于target则right–</li>
<li>当nums[left]+nums[rigth]的值小于target则left++</li>
<li>最后即可得出结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0 ;</span><br><span class="line">        int right = nums.length-1;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int temp_sum = nums[left] + nums[right];</span><br><span class="line">            if (temp_sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; else if (temp_sum &lt; target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return new int[]&#123;nums[left],nums[right]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="57-2和为s的连续正数序列"><a href="#57-2和为s的连续正数序列" class="headerlink" title="57.2和为s的连续正数序列"></a>57.2和为s的连续正数序列</h2><p><strong>题目描述</strong><br>输入一个正整数<code>target</code>，输出所有和为<code>target</code>的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排序，不同序列按照首个数字从小到大排序。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>由于求出的是一个序列，且只需要知道头部和尾部，并且其总值为target即可，所以可以利用双指针。<br>定义一个min 与一个max，max与min之间的总值为tempsum。</p>
<ul>
<li>当tempsum&gt;target的时候min++；</li>
<li>当tempsum==target的时候存储内容。<br>此后不断max都是++的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] findContinuousSequence(int target) &#123;</span><br><span class="line">        int small = 1;</span><br><span class="line">        int big = 2;</span><br><span class="line">        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        int middle = (1 + target)/2;</span><br><span class="line">        int midsum = 1;</span><br><span class="line">        int bigsum = 3;</span><br><span class="line">        while ( small &lt; middle)&#123;</span><br><span class="line">            int temp_sum = bigsum-midsum+small;</span><br><span class="line">            if (temp_sum &lt; target)&#123;</span><br><span class="line">                big++;</span><br><span class="line">                bigsum += big;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (temp_sum &gt; target)&#123;</span><br><span class="line">                small++;</span><br><span class="line">                midsum += small;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int[] tempArray = new int[big - small +1];</span><br><span class="line">                for (int i = small,j = 0;i &lt;= big; i++,j++)&#123;</span><br><span class="line">                    tempArray[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(tempArray);</span><br><span class="line">                small++;</span><br><span class="line">                midsum += small;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res.toArray(new int[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><p><strong>题目描述</strong><br>输入一个链表的头结点，从尾到头反过来返回每个结点的值（用数组返回）。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>方法一：可以先查出数组的长度，然后设置长度，最后再遍历一遍链表设置其值。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] reversePrint(ListNode head) &#123;</span><br><span class="line">        if (head == null)&#123;</span><br><span class="line">           return new int[]&#123;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       int count = 0;</span><br><span class="line">       ListNode temp = head;</span><br><span class="line">       while (temp != null)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       int[] res = new int[count];</span><br><span class="line">       temp = head;</span><br><span class="line">       while (temp != null)&#123;</span><br><span class="line">           res[count-1] = temp.val;</span><br><span class="line">           count--;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：利用递归，如果有下一个值，就跳转到到下一个值，最后使得指针反过来指引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] reversePrint(ListNode head)&#123;</span><br><span class="line">        if (head == null)&#123;</span><br><span class="line">            return new int[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(rePrint(head));</span><br><span class="line">        int[] resarr = new int[res.size()];</span><br><span class="line">        for (int i = 0 ; i &lt; res.size();i++)</span><br><span class="line">            resarr[i] = res.get(i);</span><br><span class="line">        return resarr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int rePrint(ListNode head)&#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return head.val;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(rePrint(head.next));</span><br><span class="line">        return head.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h2><p><strong>题目描述</strong><br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>如果要删除当前的节点，则需要知道当前的节点的上一个节点，因此需要一个pre节点，则当前的节点为（即为要删除的节点为）pre.next;为避免删除的为头节点可以从新建一个头节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteNode(ListNode head, int val) &#123;</span><br><span class="line">        if (head == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = new ListNode(0);</span><br><span class="line">        start.next = head;</span><br><span class="line">        ListNode res = start;</span><br><span class="line">        while (head!=null)&#123;</span><br><span class="line">            if (head.val == val)&#123;</span><br><span class="line">                start.next = head.next;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            start = start.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点"></a>22.链表中倒数第k个节点</h2><p><strong>题目描述</strong><br>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第一个节点。<br>例如，一个链表有<code>6</code>个节点，从头节点开始，它们的值依次是<code>1,2,3,4,5,6</code>。这个链表的倒数第<code>3</code>个节点是值为<code>4</code>的节点。<br>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>从题目中可以看出是找出链表中的倒数第几个，我们可以简单的找出链表的长度，然后根据其长度和要求的最后k个长度，即可得到结果。<br>能否只利用一次遍历就找出结果呢？答案是可以的，我们可以设置两个索引，一个索引指向当前的位置index，另外一个索引指向index+k的长度位置，如果当index+k这个位置的数值到达了末端，则index即为倒数第k个结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">执行结果如图下：</span><br><span class="line">Pre           cur</span><br><span class="line">1-&gt;    2-&gt;    3-&gt;    4-&gt;    5</span><br><span class="line">       Pre           cur</span><br><span class="line">1-&gt;    2-&gt;    3-&gt;    4-&gt;    5</span><br><span class="line">              Pre           cur</span><br><span class="line">1-&gt;    2-&gt;    3-&gt;    4-&gt;    5</span><br><span class="line">                     Pre           cur</span><br><span class="line">1-&gt;    2-&gt;    3-&gt;    4-&gt;    5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 鲁棒性更强，只需要遍历一遍就可以了</span><br><span class="line">    public ListNode getKthFromEnd(ListNode head, int k) &#123;</span><br><span class="line">       if (head == null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = head;</span><br><span class="line">        while (head != null &amp;&amp; k &gt; 0)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head == null)</span><br><span class="line">            return k==0?start:head;</span><br><span class="line">        while (head != null)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h2><p><strong>题目描述</strong><br>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头节点。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong><br>利用非递归，和头节点将链表反向调节。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">head curr</span><br><span class="line">1-&gt;  2-&gt;  3-&gt;  4-&gt;  5-&gt;  NULL</span><br><span class="line"></span><br><span class="line">2-&gt;  1-&gt;  3-&gt;  4-&gt;  5-&gt;NULL</span><br></pre></td></tr></table></figure>
    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt>
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt>
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/03/06/SpringBoot中注解Aspect的用法/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/06/02/HashMap源码解析/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/" rel="noopener noreferrer" target="_self">
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/" rel="noopener noreferrer" target="_self">
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/" rel="noopener noreferrer" target="_self">
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/" rel="noopener noreferrer" target="_self">
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/" rel="noopener noreferrer" target="_self">
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml" rel="noopener noreferrer" target="_blank">
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/search/" rel="noopener noreferrer" target="_self">
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-name">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '277317290454635afa73',
  clientSecret: '78223c859304da5e8d71bfce136d436c6ff95c37',
  repo: 'blog-comment',
  owner: 'forsigner',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['forsigner'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
